<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
      content="width=device-width,
               initial-scale=1.0,
               viewport-fit=cover,
               user-scalable=no" />
<title>Mobile 2D Game</title>

<style>
  html, body {
    margin: 0; padding: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: black;
    touch-action: none;
  }

  /* GAME CANVAS — top ~90% */
  #gameCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: calc(90vh - env(safe-area-inset-bottom));
    display: block;
  }

  /* Floating bottom UI buttons */
  #uiButtons {
    position: fixed;
    bottom: calc(1.5vh + env(safe-area-inset-bottom));
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1.5vh;
    z-index: 9999;
    pointer-events: none; /* children handle clicks */
    font-family: sans-serif;
    font-size: 2.2vh;
    color: white;
  }

  #defaultUI {
    white-space: nowrap;
    pointer-events: auto;
  }

  .ui-btn {
    background: rgba(255,200,150,0.95);
    padding: 1vh 2.4vh;
    border-radius: 1vh;
    font-size: 2.2vh;
    font-weight: bold;
    border: 2px solid white;
    color: black;
    display: none;
    white-space: nowrap;
    pointer-events: auto;
  }

  #fightButton { background: rgba(255,120,120,0.95); }
  #runButton   { background: rgba(180,200,255,0.95); }

  #hitButton   { background: rgba(255,230,150,0.95); }
  #smackButton { background: rgba(255,210,150,0.95); }
  #punchButton { background: rgba(255,190,150,0.95); }
  #kickButton  { background: rgba(255,170,150,0.95); }

  #joystick {
    position: absolute;
    width: 120px; height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    display: none;
    touch-action: none;
    z-index: 5000;
  }

  #stick {
    position: absolute;
    width: 60px; height: 60px;
    border-radius: 50%;
    background: rgba(255,255,255,0.4);
    left: 30px; top: 30px;
  }

  #fadeOverlay {
    position: fixed;
    inset: 0;
    background: black;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
    z-index: 12000;
  }
</style>
</head>

<body>

<canvas id="gameCanvas"></canvas>

<div id="uiButtons">
  <div id="defaultUI">UI — walk up to things…</div>

  <button id="harvestButton" class="ui-btn">HARVEST BLOSSOM</button>

  <button id="fightButton" class="ui-btn">FIGHT</button>
  <button id="runButton"   class="ui-btn">RUN</button>

  <button id="hitButton"   class="ui-btn">HIT</button>
  <button id="smackButton" class="ui-btn">SMACK</button>
  <button id="punchButton" class="ui-btn">PUNCH</button>
  <button id="kickButton"  class="ui-btn">KICK</button>
</div>

<div id="joystick"><div id="stick"></div></div>
<div id="fadeOverlay"></div>

<script>
// ===== Canvas =====
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight * 0.90;
}
resize();
window.addEventListener("resize", resize);

let currentTime = 0;

// ===== Assets =====
const bg = new Image();
bg.src = "background.png";

const collisionImg = new Image();
collisionImg.src = "collision.png";

const blossomImg = new Image();
blossomImg.src = "item_blossom.png";

const monsterIdleImg = new Image();
monsterIdleImg.src = "monster_starwolf_idle.png";

const monsterAttackImg = new Image();
monsterAttackImg.src = "monster_starwolf_attack.png";

const monsterHurtImg = new Image();
monsterHurtImg.src = "monster_starwolf_hurt.png";

const frames = ["player1.png","player2.png","player3.png"].map(src => {
  const i = new Image();
  i.src = src;
  return i;
});

// ===== Collision map =====
const colCanvas = document.createElement("canvas");
const colCtx = colCanvas.getContext("2d");
let collisionReady = false;

collisionImg.onload = () => {
  colCanvas.width = collisionImg.width;
  colCanvas.height = collisionImg.height;
  colCtx.drawImage(collisionImg, 0, 0);
  collisionReady = true;
};

function pixelBlocked(x, y) {
  if (!collisionReady) return false;
  if (x < 0 || y < 0 || x >= colCanvas.width || y >= colCanvas.height) return true;
  const d = colCtx.getImageData(x, y, 1, 1).data;
  return d[0] < 50 && d[1] < 50 && d[2] < 50;
}

function circleBlocked(cx, cy, r) {
  const N = 10;
  for (let i = 0; i < N; i++) {
    const a = (i / N) * Math.PI * 2;
    const px = cx + Math.cos(a) * r;
    const py = cy + Math.sin(a) * r;
    if (pixelBlocked(px, py)) return true;
  }
  return false;
}

// ===== Player =====
let DEBUG_HITBOX = false;

const START_X = 500;
const START_Y = 500;

let player = {
  x: START_X,
  y: START_Y,
  speed: 180,
  frame: 0,
  frameTimer: 0,
  scale: 0.20,
  facingLeft: false,
  moving: false,
  hitR: 40,
  hitOffsetY: 10,
  hpMax: 20,
  hp: 20,
  hitFlash: 0,
  lungeOffsetX: 0,
  lungeOffsetY: 0
};

// ===== Camera =====
let camera = { x: 0, y: 0 };

function clampCameraToBg() {
  const cw = canvas.width;
  const ch = canvas.height;
  if (bg.width > 0 && bg.height > 0) {
    camera.x = Math.max(0, Math.min(camera.x, bg.width - cw));
    camera.y = Math.max(0, Math.min(camera.y, bg.height - ch));
  } else {
    camera.x = 0;
    camera.y = 0;
  }
}

function updateCamera() {
  const cw = canvas.width;
  const ch = canvas.height;
  const tx = player.x - cw / 2;
  const ty = player.y - ch / 2;
  camera.x += (tx - camera.x) * 0.1;
  camera.y += (ty - camera.y) * 0.1;
  clampCameraToBg();
}

// ===== Joystick =====
const joyDiv = document.getElementById("joystick");
const stick = document.getElementById("stick");
let joy = { active:false, dx:0, dy:0, originX:0, originY:0 };

canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  joy.active = true;
  joy.originX = t.clientX;
  joy.originY = t.clientY;
  joyDiv.style.left = (t.clientX - 60) + "px";
  joyDiv.style.top  = (t.clientY - 60) + "px";
  joyDiv.style.display = "block";
  stick.style.left = "30px";
  stick.style.top  = "30px";
});

canvas.addEventListener("touchmove", e => {
  if (!joy.active) return;
  const t = e.touches[0];
  const dx = t.clientX - joy.originX;
  const dy = t.clientY - joy.originY;
  const dist = Math.hypot(dx, dy);
  const max = 40;
  let ndx = dx, ndy = dy;
  if (dist > max) {
    ndx = (dx / dist) * max;
    ndy = (dy / dist) * max;
  }
  stick.style.left = (30 + ndx) + "px";
  stick.style.top  = (30 + ndy) + "px";
  joy.dx = ndx / max;
  joy.dy = ndy / max;
});

canvas.addEventListener("touchend", () => {
  joy.active = false;
  joy.dx = joy.dy = 0;
  joyDiv.style.display = "none";
});

// ===== Items =====
let items = [
  { type: "blossom", x: 250, y: 250, harvested: false }
];

// ===== Monster =====
let monster = {
  x: 400,
  y: 200,
  alive: true,
  hpMax: 10,
  hp: 10,
  scale: 0.30,
  state: "idle",   // visual: idle/attack/dying
  aiState: "roam", // logic: roam/pause/aggro/battle/dying
  fadeAlpha: 1,
  hitFlash: 0,
  lungeOffsetX: 0,
  lungeOffsetY: 0,
  facingLeft: false,
  roamSpeed: 40,
  roamDirX: 1,
  roamDirY: 0,
  roamTimer: 0,
  pauseTimer: 0
};

function startMonsterRoam() {
  monster.aiState = "roam";
  const angle = Math.random() * Math.PI * 2;
  monster.roamDirX = Math.cos(angle);
  monster.roamDirY = Math.sin(angle);
  monster.roamTimer = 0.8 + Math.random() * 1.2;
  if (monster.roamDirX < -0.1) monster.facingLeft = true;
  else if (monster.roamDirX > 0.1) monster.facingLeft = false;
}

function startMonsterPause() {
  monster.aiState = "pause";
  monster.pauseTimer = 0.7 + Math.random() * 0.8;
}
startMonsterRoam();

// ===== UI & modes =====
const defaultUI   = document.getElementById("defaultUI");
const harvestBtn  = document.getElementById("harvestButton");
const fightBtn    = document.getElementById("fightButton");
const runBtn      = document.getElementById("runButton");
const hitBtn      = document.getElementById("hitButton");
const smackBtn    = document.getElementById("smackButton");
const punchBtn    = document.getElementById("punchButton");
const kickBtn     = document.getElementById("kickButton");
const fadeOverlay = document.getElementById("fadeOverlay");

let currentUIMode = "default"; // default | blossom | monsterChoice | battle | none
let battleMode = false;
let battleBusy = false;
let runTeleportInProgress = false;

function setUIMode(mode) {
  currentUIMode = mode;

  defaultUI.style.display  = (mode === "default") ? "block" : "none";
  harvestBtn.style.display = (mode === "blossom") ? "inline-block" : "none";

  const monsterChoice = (mode === "monsterChoice");
  fightBtn.style.display = monsterChoice ? "inline-block" : "none";
  runBtn.style.display   = monsterChoice ? "inline-block" : "none";

  const battle = (mode === "battle");
  hitBtn.style.display   = battle ? "inline-block" : "none";
  smackBtn.style.display = battle ? "inline-block" : "none";
  punchBtn.style.display = battle ? "inline-block" : "none";
  kickBtn.style.display  = battle ? "inline-block" : "none";

  if (mode === "none") {
    defaultUI.style.display  = "none";
    harvestBtn.style.display = "none";
    fightBtn.style.display   = "none";
    runBtn.style.display     = "none";
    hitBtn.style.display     = "none";
    smackBtn.style.display   = "none";
    punchBtn.style.display   = "none";
    kickBtn.style.display    = "none";
  }
}
setUIMode("default");

function movementLocked() {
  return (
    battleMode ||
    runTeleportInProgress ||
    currentUIMode === "monsterChoice"
  );
}

// Blossom
harvestBtn.addEventListener("click", () => {
  const item = items.find(i => i.type === "blossom" && !i.harvested);
  if (item) item.harvested = true;
  setUIMode("default");
});

// ===== Battle & run =====
function resetLunges() {
  player.lungeOffsetX = player.lungeOffsetY = 0;
  monster.lungeOffsetX = monster.lungeOffsetY = 0;
}

fightBtn.addEventListener("click", () => {
  if (!monster.alive) return;
  battleMode = true;
  battleBusy = false;
  monster.aiState = "battle";
  monster.state = "attack";
  setUIMode("battle");
});

runBtn.addEventListener("click", () => {
  if (!monster.alive) return;
  battleMode = false;
  battleBusy = false;
  monster.aiState = "roam";
  monster.state = "idle";
  setUIMode("none");
  resetLunges();
  startRunTeleport();
});

function performMonsterCounterAttack() {
  if (!monster.alive || !battleMode) {
    battleBusy = false;
    return;
  }

  monster.state = "attack";
  const dx = player.x - monster.x;
  const dy = player.y - monster.y;
  const len = Math.hypot(dx, dy) || 1;
  const LUNGE = 20;

  monster.facingLeft = dx < 0;
  monster.lungeOffsetX = (dx / len) * LUNGE;
  monster.lungeOffsetY = (dy / len) * LUNGE;

  const DMG = 2;
  player.hp -= DMG;
  if (player.hp < 0) player.hp = 0;
  player.hitFlash = 0.18;

  if (player.hp <= 0) {
    battleMode = false;
    battleBusy = false;
    monster.aiState = "roam";
    monster.state = "idle";
    setUIMode("none");
    resetLunges();
    startRunTeleport(() => {
      player.hp = player.hpMax;
    });
    return;
  }

  setTimeout(() => {
    monster.lungeOffsetX = 0;
    monster.lungeOffsetY = 0;
    if (monster.alive && monster.aiState !== "dying") {
      monster.state = "idle";
    }
    if (battleMode) {
      battleBusy = false;
      setUIMode("battle");
    }
  }, 200);
}

function performAttack(dmg) {
  if (!battleMode || !monster.alive || battleBusy) return;
  battleBusy = true;
  setUIMode("battle");

  const dx = monster.x - player.x;
  const dy = monster.y - player.y;
  const len = Math.hypot(dx, dy) || 1;
  const LUNGE = 15;

  player.lungeOffsetX = (dx / len) * LUNGE;
  player.lungeOffsetY = (dy / len) * LUNGE;

  monster.hp -= dmg;
  if (monster.hp < 0) monster.hp = 0;
  monster.hitFlash = 0.18;

  if (monster.hp <= 0) {
    monster.hp = 0;
    if (monster.alive) {
      monster.alive = false;
      monster.state = "dying";
      monster.aiState = "dying";
      monster.fadeAlpha = 1;
    }
    setTimeout(() => {
      battleMode = false;
      battleBusy = false;
      setUIMode("default");
      resetLunges();
    }, 250);
    return;
  }

  setTimeout(() => {
    player.lungeOffsetX = 0;
    player.lungeOffsetY = 0;
    monster.hitFlash = 0;

    if (!battleMode || !monster.alive) {
      battleBusy = false;
      return;
    }

    setTimeout(() => {
      performMonsterCounterAttack();
    }, 500);
  }, 180);
}

hitBtn.addEventListener("click",   () => performAttack(2));
smackBtn.addEventListener("click", () => performAttack(3));
punchBtn.addEventListener("click", () => performAttack(4));
kickBtn.addEventListener("click",  () => performAttack(5));

// ===== Run teleport =====
function startRunTeleport(onAfterTeleport) {
  runTeleportInProgress = true;
  fadeOverlay.style.pointerEvents = "auto";
  fadeOverlay.style.opacity = "1";

  setTimeout(() => {
    player.x = START_X;
    player.y = START_Y;
    camera.x = player.x - canvas.width / 2;
    camera.y = player.y - canvas.height / 2;
    clampCameraToBg();

    if (typeof onAfterTeleport === "function") onAfterTeleport();

    fadeOverlay.style.opacity = "0";
    setTimeout(() => {
      fadeOverlay.style.pointerEvents = "none";
      runTeleportInProgress = false;
      setUIMode("default");
    }, 400);
  }, 400);
}

// ===== Monster roaming AI =====
function updateMonsterAI(dt) {
  if (!monster.alive || monster.aiState === "dying") return;
  if (battleMode) {
    monster.aiState = "battle";
    return;
  }

  if (monster.aiState === "aggro") {
    return; // freeze in place when FIGHT/RUN is up
  }

  if (monster.aiState === "pause") {
    monster.pauseTimer -= dt;
    if (monster.pauseTimer <= 0) {
      startMonsterRoam();
    }
  } else if (monster.aiState === "roam") {
    const speed = monster.roamSpeed;
    const nextX = monster.x + monster.roamDirX * speed * dt;
    const nextY = monster.y + monster.roamDirY * speed * dt;

    const probeOffsetY = 10;
    const probeRadius = 30;

    if (!circleBlocked(nextX, nextY + probeOffsetY, probeRadius)) {
      monster.x = nextX;
      monster.y = nextY;
    } else {
      startMonsterPause();
      return;
    }

    monster.roamTimer -= dt;
    if (monster.roamTimer <= 0) {
      startMonsterPause();
    }
  }
}

// ===== Loop =====
let last = 0;
function loop(t) {
  const dt = (t - last) / 1000;
  last = t;
  currentTime = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ===== Update =====
function update(dt) {
  const lockMove = movementLocked();

  if (!lockMove) {
    player.moving = Math.abs(joy.dx) > 0.05 || Math.abs(joy.dy) > 0.05;
    if (player.moving) {
      const nextX = player.x + joy.dx * player.speed * dt;
      const nextY = player.y + joy.dy * player.speed * dt;
      if (!circleBlocked(nextX, player.y + player.hitOffsetY, player.hitR))
        player.x = nextX;
      if (!circleBlocked(player.x, nextY + player.hitOffsetY, player.hitR))
        player.y = nextY;
    }
  } else {
    player.moving = false;
  }

  if (player.moving) {
    player.frameTimer += dt;
    if (player.frameTimer > 0.15) {
      player.frame = (player.frame + 1) % 3;
      player.frameTimer = 0;
    }
  } else {
    player.frame = 0;
  }

  if (!lockMove) {
    if (joy.dx < -0.05) player.facingLeft = true;
    else if (joy.dx > 0.05) player.facingLeft = false;
  }

  if (player.hitFlash > 0) {
    player.hitFlash -= dt;
    if (player.hitFlash < 0) player.hitFlash = 0;
  }
  if (monster.hitFlash > 0) {
    monster.hitFlash -= dt;
    if (monster.hitFlash < 0) monster.hitFlash = 0;
  }

  if (!monster.alive && monster.aiState === "dying") {
    monster.fadeAlpha -= dt * 1.8;
    if (monster.fadeAlpha < 0) monster.fadeAlpha = 0;
  }

  player.lungeOffsetX *= 0.85;
  player.lungeOffsetY *= 0.85;
  if (Math.abs(player.lungeOffsetX) < 0.01) player.lungeOffsetX = 0;
  if (Math.abs(player.lungeOffsetY) < 0.01) player.lungeOffsetY = 0;

  monster.lungeOffsetX *= 0.85;
  monster.lungeOffsetY *= 0.85;
  if (Math.abs(monster.lungeOffsetX) < 0.01) monster.lungeOffsetX = 0;
  if (Math.abs(monster.lungeOffsetY) < 0.01) monster.lungeOffsetY = 0;

  updateMonsterAI(dt);

  // proximity UI (only when not locked)
  if (!movementLocked()) {
    let nearMonster = false;
    if (monster.alive) {
      const dx = player.x - monster.x;
      const dy = player.y - monster.y;
      const dist = Math.hypot(dx, dy);
      if (dist < 90) nearMonster = true;
    }

    let nearBlossom = false;
    if (!nearMonster) {
      for (const item of items) {
        if (item.harvested) continue;
        const dx = player.x - item.x;
        const dy = player.y - item.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 80) { nearBlossom = true; break; }
      }
    }

    if (nearMonster) {
      setUIMode("monsterChoice");
      if (monster.alive && !battleMode) {
        monster.aiState = "aggro";
        monster.state  = "attack";
        monster.roamTimer  = 0;
        monster.pauseTimer = 9999;
        const dx = player.x - monster.x;
        if (dx < 0) monster.facingLeft = true;
        else if (dx > 0) monster.facingLeft = false;
      }
    } else if (nearBlossom) {
      setUIMode("blossom");
      if (monster.alive && monster.aiState === "aggro" && !battleMode) {
        monster.aiState = "roam";
        monster.state = "idle";
        startMonsterRoam();
      }
    } else if (currentUIMode !== "default") {
      setUIMode("default");
      if (monster.alive && monster.aiState === "aggro" && !battleMode) {
        monster.aiState = "roam";
        monster.state = "idle";
        startMonsterRoam();
      }
    }
  }

  updateCamera();
}

// ===== Draw helpers =====
function drawHPBubbleOval(worldX, worldY, hp, hpMax) {
  const screenX = worldX - camera.x;
  const screenY = worldY - camera.y;
  const text = `♥ ${hp}/${hpMax}`;
  ctx.save();
  ctx.font = "12px sans-serif";
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";

  const paddingX = 6;
  const textWidth = ctx.measureText(text).width;
  const w = textWidth + paddingX * 2;
  const h = 18;
  const cx = screenX;
  const cy = screenY;
  const rx = w / 2;
  const ry = h / 2;

  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.ellipse(cx, cy + 2, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "white";
  ctx.beginPath();
  ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "black";
  ctx.fillText(text, cx, cy);
  ctx.restore();
}

function drawHitFlashRect(x, y, w, h, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = "red";
  ctx.fillRect(x, y, w, h);
  ctx.restore();
}

// ===== Draw =====
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.drawImage(
    bg,
    camera.x, camera.y,
    canvas.width, canvas.height,
    0, 0,
    canvas.width, canvas.height
  );

  // Blossom
  for (const item of items) {
    if (item.harvested) continue;
    if (item.type === "blossom") {
      const size = 80;
      ctx.drawImage(
        blossomImg,
        item.x - camera.x - size / 2,
        item.y - camera.y - size / 2,
        size, size
      );
    }
  }

  // Monster
  if (monster.alive || (monster.aiState === "dying" && monster.fadeAlpha > 0)) {
    let mImg = monsterIdleImg;
    if (monster.aiState === "dying") {
      mImg = monsterHurtImg;
    } else if (monster.hitFlash > 0) {
      mImg = monsterHurtImg;
    } else if (
      monster.state === "attack" ||
      (monster.alive && currentUIMode === "monsterChoice" && !battleMode)
    ) {
      mImg = monsterAttackImg;
    }

    const baseScale = monster.scale;
    const mw = mImg.width * baseScale;
    const mh = mImg.height * baseScale;
    const worldMX = monster.x + monster.lungeOffsetX;
    const worldMY = monster.y + monster.lungeOffsetY;
    const screenMX = worldMX - camera.x;
    const screenMY = worldMY - camera.y;

    // Bobbing & breathing only while roaming & not in battle
    let bob = 0;
    let breathe = 1;
    if (monster.aiState === "roam" && !battleMode) {
      bob = Math.sin(currentTime / 500) * 4;
      breathe = 1 + Math.sin(currentTime / 700) * 0.02;
    }

    ctx.save();
    ctx.globalAlpha = (monster.aiState === "dying") ? monster.fadeAlpha : 1;
    ctx.translate(screenMX, screenMY + bob);
    let scaleX = monster.facingLeft ? -1 : 1;
    scaleX *= breathe;
    ctx.scale(scaleX, breathe);
    ctx.drawImage(mImg, -mw / 2, -mh / 2, mw, mh);
    ctx.restore();

    if (monster.hitFlash > 0) {
      const alpha = (monster.hitFlash / 0.18) * 0.18;
      const fxW = mw * breathe;
      const fxH = mh * breathe;
      const fxX = screenMX - fxW / 2;
      const fxY = (screenMY + bob) - fxH / 2;
      drawHitFlashRect(fxX, fxY, fxW, fxH, alpha);
    }

    if (battleMode && monster.alive) {
      drawHPBubbleOval(monster.x, monster.y - 60, monster.hp, monster.hpMax);
    }
  }

  // Player
  const img = frames[player.frame];
  const w = img.width * player.scale;
  const h = img.height * player.scale;
  const worldPX = player.x + player.lungeOffsetX;
  const worldPY = player.y + player.lungeOffsetY;
  const drawX = worldPX - camera.x - w / 2;
  const drawY = worldPY - camera.y - h / 2;

  if (player.facingLeft) {
    ctx.save();
    ctx.translate(drawX + w/2, drawY + h/2);
    ctx.scale(-1, 1);
    ctx.drawImage(img, -w/2, -h/2, w, h);
    ctx.restore();
  } else {
    ctx.drawImage(img, drawX, drawY, w, h);
  }

  if (player.hitFlash > 0) {
    const alpha = (player.hitFlash / 0.18) * 0.18;
    drawHitFlashRect(drawX, drawY, w, h, alpha);
  }

  if (battleMode) {
    drawHPBubbleOval(player.x, player.y - 60, player.hp, player.hpMax);
  }

  if (DEBUG_HITBOX) {
    const c2x = player.x - camera.x;
    const c2y = player.y - camera.y + player.hitOffsetY;
    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(c2x, c2y, player.hitR, 0, Math.PI * 2);
    ctx.stroke();

    ctx.fillStyle = "cyan";
    for (let i = 0; i < 10; i++) {
      const a = (i / 10) * Math.PI * 2;
      const px = c2x + Math.cos(a) * player.hitR;
      const py = c2y + Math.sin(a) * player.hitR;
      ctx.fillRect(px - 2, py - 2, 4, 4);
    }
  }
}
</script>

</body>
</html>
