<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Pixel Perfect Collision Test</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
    touch-action: none;
  }

  /* The game canvas is a fixed 768×768 world.
     We scale it with CSS transform to fit the screen. */
  #gameCanvas {
    position: fixed;
    left: 50%;
    top: 50%;
    transform-origin: top left;
    image-rendering: pixelated;
  }

  /* Joystick overlay (screen-space, not scaled) */
  #joystick {
    position: fixed;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    display: none;
    z-index: 10;
    touch-action: none;
  }
  #stick {
    position: absolute;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: rgba(255,255,255,0.4);
    left: 30px;
    top: 30px;
    touch-action: none;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<div id="joystick"><div id="stick"></div></div>

<script>
// ========================================================
// CONSTANTS & DEBUG
// ========================================================
const GAME_W = 768; // internal game resolution (world units)
const GAME_H = 768;

let DEBUG = true;   // set to false later when you're happy

// ========================================================
// CANVAS SETUP (pixel-perfect core 768×768)
// ========================================================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d", { alpha: false });

canvas.width = GAME_W;
canvas.height = GAME_H;

function updateCanvasScale() {
  const scale = Math.min(
    window.innerWidth / GAME_W,
    window.innerHeight / GAME_H
  );

  canvas.style.width = GAME_W + "px";
  canvas.style.height = GAME_H + "px";

  canvas.style.transform = `translate(-50%, -50%) scale(${scale})`;
}

window.addEventListener("resize", updateCanvasScale);
updateCanvasScale();

// ========================================================
// ASSETS
// ========================================================
const bg = new Image();
bg.src = "background.png"; // 768×768

const colImg = new Image();
colImg.src = "collision.png"; // 768×768, black = blocked

const frames = ["player1.png", "player2.png", "player3.png"].map(src => {
  const img = new Image();
  img.src = src;
  return img;
});

// ========================================================
// COLLISION MAP (offscreen canvas, 1:1 with world)
// ========================================================
const colCanvas = document.createElement("canvas");
const colCtx = colCanvas.getContext("2d");
let colReady = false;

colImg.onload = () => {
  colCanvas.width = colImg.width;
  colCanvas.height = colImg.height;
  colCtx.drawImage(colImg, 0, 0);
  colReady = true;
};

function isBlocked(px, py) {
  if (!colReady) return false;

  if (px < 0 || py < 0 || px >= colCanvas.width || py >= colCanvas.height) {
    return true;
  }

  const d = colCtx.getImageData(px, py, 1, 1).data;
  return d[0] < 50 && d[1] < 50 && d[2] < 50;
}

// box collision in WORLD coordinates
function isBoxBlocked(x, y, w, h, offsetY) {
  const cx = x;
  const cy = y + offsetY; // move box down towards feet

  const hw = w / 2;
  const hh = h / 2;

  const corners = [
    { x: cx - hw, y: cy - hh },
    { x: cx + hw, y: cy - hh },
    { x: cx - hw, y: cy + hh },
    { x: cx + hw, y: cy + hh },
  ];

  for (const pt of corners) {
    if (isBlocked(pt.x, pt.y)) return true;
  }
  return false;
}

// ========================================================
// PLAYER
// ========================================================
let player = {
  x: 500,
  y: 500,
  speed: 180,

  frame: 0,
  frameTimer: 0,
  scale: 1.0,          // 1:1 sprite pixels to world pixels

  moving: false,
  facingLeft: false,

  // collision box (tune with debug)
  boxW: 18,
  boxH: 12,
  boxOffsetY: 10      // how far below the center the feet are
};

// ========================================================
// CAMERA (for now, world == viewport, so this will clamp to 0)
// ========================================================
let camera = { x: 0, y: 0 };

function updateCamera() {
  let tx = player.x - GAME_W / 2;
  let ty = player.y - GAME_H / 2;

  // world bounds (same as bg size)
  const WORLD_W = GAME_W;
  const WORLD_H = GAME_H;

  tx = Math.max(0, Math.min(tx, WORLD_W - GAME_W));
  ty = Math.max(0, Math.min(ty, WORLD_H - GAME_H));

  camera.x += (tx - camera.x) * 0.1;
  camera.y += (ty - camera.y) * 0.1;
}

// ========================================================
// JOYSTICK (screen-space, not scaled)
// ========================================================
const joyDiv = document.getElementById("joystick");
const stick = document.getElementById("stick");

let joy = { active: false, dx: 0, dy: 0, originX: 0, originY: 0 };

window.addEventListener("touchstart", e => {
  const t = e.touches[0];
  joy.active = true;
  joy.originX = t.clientX;
  joy.originY = t.clientY;

  joyDiv.style.left = (t.clientX - 60) + "px";
  joyDiv.style.top  = (t.clientY - 60) + "px";
  joyDiv.style.display = "block";

  stick.style.left = "30px";
  stick.style.top  = "30px";
}, { passive: false });

window.addEventListener("touchmove", e => {
  if (!joy.active) return;
  const t = e.touches[0];

  let dx = t.clientX - joy.originX;
  let dy = t.clientY - joy.originY;
  const dist = Math.hypot(dx, dy);
  const max = 40;

  if (dist > max) {
    dx *= max / dist;
    dy *= max / dist;
  }

  joy.dx = dx / max;
  joy.dy = dy / max;

  stick.style.left = (30 + dx) + "px";
  stick.style.top  = (30 + dy) + "px";

  e.preventDefault();
}, { passive: false });

window.addEventListener("touchend", () => {
  joy.active = false;
  joy.dx = joy.dy = 0;
  joyDiv.style.display = "none";
});

// ========================================================
// GAME LOOP
// ========================================================
let last = 0;
function loop(t) {
  const dt = (t - last) / 1000;
  last = t;

  update(dt);
  draw();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ========================================================
// UPDATE
// ========================================================
function update(dt) {
  player.moving = Math.abs(joy.dx) > 0.05 || Math.abs(joy.dy) > 0.05;

  if (player.moving) {
    const nextX = player.x + joy.dx * player.speed * dt;
    const nextY = player.y + joy.dy * player.speed * dt;

    if (!isBoxBlocked(nextX, player.y, player.boxW, player.boxH, player.boxOffsetY)) {
      player.x = nextX;
    }
    if (!isBoxBlocked(player.x, nextY, player.boxW, player.boxH, player.boxOffsetY)) {
      player.y = nextY;
    }
  }

  if (joy.dx < -0.05) player.facingLeft = true;
  else if (joy.dx > 0.05) player.facingLeft = false;

  if (player.moving) {
    player.frameTimer += dt;
    if (player.frameTimer > 0.15) {
      player.frame = (player.frame + 1) % 3;
      player.frameTimer = 0;
    }
  } else {
    player.frame = 0;
  }

  updateCamera();
}

// ========================================================
// DRAW + DEBUG
// ========================================================
function draw() {
  ctx.clearRect(0, 0, GAME_W, GAME_H);
  ctx.imageSmoothingEnabled = false;

  // Background — pixel perfect, no scaling
  if (bg.complete && bg.width > 0) {
    ctx.drawImage(
      bg,
      camera.x, camera.y,
      GAME_W, GAME_H,
      0, 0,
      GAME_W, GAME_H
    );
  }

  // Player sprite
  const img = frames[player.frame];
  const w = img.width * player.scale;
  const h = img.height * player.scale;

  const sx = player.x - camera.x - w / 2;
  const sy = player.y - camera.y - h / 2;

  if (player.facingLeft) {
    ctx.save();
    ctx.translate(sx + w / 2, sy + h / 2);
    ctx.scale(-1, 1);
    ctx.drawImage(img, -w/2, -h/2, w, h);
    ctx.restore();
  } else {
    ctx.drawImage(img, sx, sy, w, h);
  }

  // DEBUG collision box
  if (DEBUG) {
    const cx = player.x - camera.x;
    const cy = player.y - camera.y + player.boxOffsetY;
    const hw = player.boxW / 2;
    const hh = player.boxH / 2;

    // red box
    ctx.strokeStyle = "red";
    ctx.lineWidth = 1;
    ctx.strokeRect(cx - hw, cy - hh, player.boxW, player.boxH);

    // cyan corners
    ctx.fillStyle = "cyan";
    const corners = [
      { x: cx - hw, y: cy - hh },
      { x: cx + hw, y: cy - hh },
      { x: cx - hw, y: cy + hh },
      { x: cx + hw, y: cy + hh }
    ];
    corners.forEach(pt => {
      ctx.fillRect(pt.x - 2, pt.y - 2, 4, 4);
    });
  }
}
</script>
</body>
</html>
