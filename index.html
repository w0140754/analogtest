<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Mobile 2D Game</title>

<style>
  html, body {
    margin: 0; padding: 0;
    overflow: hidden;
    background: black;
    height: 100vh;
    width: 100vw;
    touch-action: none;
  }

  /* TRUE GAMEPLAY AREA */
  #gameCanvas {
    display: block;
    width: 100vw;
    height: 90vh;
  }

  /* UI BAR (10%) */
  #uiBar {
    width: 100vw;
    height: 10vh;
    background: rgba(20,20,20,0.7);
    backdrop-filter: blur(5px);
    color: white;
    font-family: sans-serif;
    font-size: 2.2vh;
    border-top: 1px solid rgba(255,255,255,0.15);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Big centered Harvest Button */
  #harvestButton {
    background: rgba(255,200,150,0.9);
    padding: 1vh 2vh;
    border-radius: 1vh;
    font-size: 2.5vh;
    font-weight: bold;
    border: 2px solid white;
    color: black;
    display: none;   /* shown only near item */
  }

  /* Joystick */
  #joystick {
    position: absolute;
    width: 120px; height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    display: none;
    touch-action: none;
    z-index: 5;
  }

  #stick {
    position: absolute;
    width: 60px; height: 60px;
    border-radius: 50%;
    background: rgba(255,255,255,0.4);
    left: 30px; top: 30px;
  }
</style>
</head>

<body>

<!-- GAME CANVAS (top 90%) -->
<canvas id="gameCanvas"></canvas>

<!-- UI BAR (bottom 10%) -->
<div id="uiBar">
  <div id="defaultUI">UI BAR â€” buttons go here</div>
  <button id="harvestButton">HARVEST BLOSSOM</button>
</div>

<!-- JOYSTICK -->
<div id="joystick"><div id="stick"></div></div>

<script>
// =====================================================
// CANVAS SETUP
// =====================================================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight * 0.90;  // TOP 90%
}
resize();
window.addEventListener("resize", resize);

// =====================================================
// ASSETS
// =====================================================
const bg = new Image();
bg.src = "background.png";

const collisionImg = new Image();
collisionImg.src = "collision.png";

const blossomImg = new Image();
blossomImg.src = "item_blossom.png";

const frames = ["player1.png","player2.png","player3.png"].map(src => {
  const i = new Image();
  i.src = src;
  return i;
});

// =====================================================
// COLLISION MAP
// =====================================================
const colCanvas = document.createElement("canvas");
const colCtx = colCanvas.getContext("2d");
let collisionReady = false;

collisionImg.onload = () => {
  colCanvas.width = collisionImg.width;
  colCanvas.height = collisionImg.height;
  colCtx.drawImage(collisionImg, 0, 0);
  collisionReady = true;
};

function pixelBlocked(x, y) {
  if (!collisionReady) return false;
  if (x < 0 || y < 0 || x >= colCanvas.width || y >= colCanvas.height) return true;
  const d = colCtx.getImageData(x, y, 1, 1).data;
  return d[0] < 50 && d[1] < 50 && d[2] < 50;
}

// =====================================================
// CIRCLE HITBOX
// =====================================================
function circleBlocked(cx, cy, r) {
  const N = 10;
  for (let i = 0; i < N; i++) {
    const angle = (i / N) * Math.PI * 2;
    const px = cx + Math.cos(angle) * r;
    const py = cy + Math.sin(angle) * r;
    if (pixelBlocked(px, py)) return true;
  }
  return false;
}

// =====================================================
// PLAYER
// =====================================================
let DEBUG_HITBOX = true;

let player = {
  x: 500,
  y: 500,
  speed: 180,
  frame: 0,
  frameTimer: 0,
  scale: 0.20,
  facingLeft: false,
  moving: false,

  hitR: 40,
  hitOffsetY: 10
};

// =====================================================
// CAMERA
// =====================================================
let camera = { x: 0, y: 0 };

function updateCamera() {
  const cw = canvas.width;
  const ch = canvas.height;

  let tx = player.x - cw / 2;
  let ty = player.y - ch / 2;

  tx = Math.max(0, Math.min(tx, bg.width - cw));
  ty = Math.max(0, Math.min(ty, bg.height - ch));

  camera.x += (tx - camera.x) * 0.1;
  camera.y += (ty - camera.y) * 0.1;
}

// =====================================================
// JOYSTICK
// =====================================================
const joyDiv = document.getElementById("joystick");
const stick = document.getElementById("stick");

let joy = { active:false, dx:0, dy:0, originX:0, originY:0 };

canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  joy.active = true;
  joy.originX = t.clientX;
  joy.originY = t.clientY;

  joyDiv.style.left = (t.clientX - 60) + "px";
  joyDiv.style.top  = (t.clientY - 60) + "px";
  joyDiv.style.display = "block";

  stick.style.left = "30px";
  stick.style.top  = "30px";
});

canvas.addEventListener("touchmove", e => {
  if (!joy.active) return;
  const t = e.touches[0];

  const dx = t.clientX - joy.originX;
  const dy = t.clientY - joy.originY;
  const dist = Math.hypot(dx, dy);
  const max = 40;

  let ndx = dx, ndy = dy;
  if (dist > max) {
    ndx = (dx / dist) * max;
    ndy = (dy / dist) * max;
  }

  stick.style.left = (30 + ndx) + "px";
  stick.style.top  = (30 + ndy) + "px";

  joy.dx = ndx / max;
  joy.dy = ndy / max;
});

canvas.addEventListener("touchend", () => {
  joy.active = false;
  joy.dx = joy.dy = 0;
  joyDiv.style.display = "none";
});

// =====================================================
// ITEMS SYSTEM
// =====================================================

// One blossom at (250, 250)
let items = [
  {
    type: "blossom",
    x: 250,
    y: 250,
    harvested: false
  }
];

// =====================================================
// UI BUTTON LOGIC
// =====================================================
const defaultUI = document.getElementById("defaultUI");
const harvestButton = document.getElementById("harvestButton");

harvestButton.addEventListener("click", () => {
  // find the blossom and remove it
  const item = items.find(i => !i.harvested && i.type === "blossom");
  if (item) item.harvested = true;

  // restore UI
  harvestButton.style.display = "none";
  defaultUI.style.display = "block";
});

// =====================================================
// GAME LOOP
// =====================================================
let last = 0;
function loop(t) {
  const dt = (t - last) / 1000;
  last = t;

  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// =====================================================
// UPDATE
// =====================================================
function update(dt) {
  player.moving = Math.abs(joy.dx) > 0.05 || Math.abs(joy.dy) > 0.05;

  if (player.moving) {
    const nextX = player.x + joy.dx * player.speed * dt;
    const nextY = player.y + joy.dy * player.speed * dt;

    if (!circleBlocked(nextX, player.y + player.hitOffsetY, player.hitR))
      player.x = nextX;

    if (!circleBlocked(player.x, nextY + player.hitOffsetY, player.hitR))
      player.y = nextY;
  }

  // Facing
  if (joy.dx < -0.05) player.facingLeft = true;
  else if (joy.dx > 0.05) player.facingLeft = false;

  // Animation
  if (player.moving) {
    player.frameTimer += dt;
    if (player.frameTimer > 0.15) {
      player.frame = (player.frame + 1) % 3;
      player.frameTimer = 0;
    }
  } else {
    player.frame = 0;
  }

  // Check proximity to blossom
  let nearBlossom = false;
  for (const item of items) {
    if (item.harvested) continue;

    const dx = player.x - item.x;
    const dy = player.y - item.y;
    const dist = Math.hypot(dx, dy);

    if (dist < 80) { // interaction distance
      nearBlossom = true;
      break;
    }
  }

  // Update UI
  if (nearBlossom) {
    defaultUI.style.display = "none";
    harvestButton.style.display = "block";
  } else {
    harvestButton.style.display = "none";
    defaultUI.style.display = "block";
  }

  updateCamera();
}

// =====================================================
// DRAW
// =====================================================
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw background
  ctx.drawImage(
    bg,
    camera.x, camera.y,
    canvas.width, canvas.height,
    0, 0,
    canvas.width, canvas.height
  );

  // Draw items
  for (const item of items) {
    if (item.harvested) continue;

    if (item.type === "blossom") {
      const size = 32; // draw size
      ctx.drawImage(
        blossomImg,
        item.x - camera.x - size/2,
        item.y - camera.y - size/2,
        size,
        size
      );
    }
  }

  // Draw player
  const img = frames[player.frame];
  const w = img.width * player.scale;
  const h = img.height * player.scale;

  const drawX = player.x - camera.x - w/2;
  const drawY = player.y - camera.y - h/2;

  if (player.facingLeft) {
    ctx.save();
    ctx.translate(drawX + w/2, drawY + h/2);
    ctx.scale(-1, 1);
    ctx.drawImage(img, -w/2, -h/2, w, h);
    ctx.restore();
  } else {
    ctx.drawImage(img, drawX, drawY, w, h);
  }

  // DEBUG HITBOX
  if (DEBUG_HITBOX) {
    const cx = player.x - camera.x;
    const cy = player.y - camera.y + player.hitOffsetY;

    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, player.hitR, 0, Math.PI * 2);
    ctx.stroke();

    ctx.fillStyle = "cyan";
    for (let i = 0; i < 10; i++) {
      const a = i / 10 * Math.PI * 2;
      const px = cx + Math.cos(a) * player.hitR;
      const py = cy + Math.sin(a) * player.hitR;
      ctx.fillRect(px - 2, py - 2, 4, 4);
    }
  }
}
</script>

</body>
</html>
