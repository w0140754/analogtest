<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,viewport-fit=cover,user-scalable=no" />
<title>Innerworld</title>

<style>
html, body {
  margin: 0; padding: 0;
  width: 100vw; height: 100vh;
  overflow: hidden;
  background: black;
  touch-action: none;
}

#gameCanvas {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: calc(90vh - env(safe-area-inset-bottom));
}

/* Joystick */
#joystick {
  position: absolute;
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: rgba(255,255,255,0.15);
  display: none;
  touch-action: none;
  z-index: 5000;
}
#stick {
  position: absolute;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: rgba(255,255,255,0.4);
  left: 30px;
  top: 30px;
}
</style>
</head>

<body>

<canvas id="gameCanvas"></canvas>

<!-- Joystick -->
<div id="joystick"><div id="stick"></div></div>

<script>
// ======================================================
// LOAD ENTRY FROM OUTERWORLD
// ======================================================
const raw = localStorage.getItem("innerworld_entry");
if (!raw) {
  alert("No game save found. Returning to map...");
  window.location.href = "index.html";
}
const entry = JSON.parse(raw);

const TILE_TYPE    = entry.tile.type;
const TILE_RARITY  = entry.tile.rarity;
const PLAYER_START = entry.playerStart;

// ======================================================
// CANVAS
// ======================================================
const canvas = document.getElementById("gameCanvas");
const ctx    = canvas.getContext("2d");

function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight * 0.90;
}
resize();
window.addEventListener("resize", resize);

// ======================================================
// ASSETS: dynamic background + collision map
// ======================================================
const bg = new Image();
bg.src = `innerworld/${TILE_TYPE}_${TILE_RARITY}_bg.png`;

const collisionImg = new Image();
collisionImg.src = `collision/${TILE_TYPE}_${TILE_RARITY}_col.png`;

const frames = ["player1.png","player2.png","player3.png"].map(src => {
  const i = new Image();
  i.src = src;
  return i;
});

// ======================================================
// COLLISION MAP SETUP
// ======================================================
const colCanvas = document.createElement("canvas");
const colCtx = colCanvas.getContext("2d");
let collisionReady = false;

collisionImg.onload = () => {
  colCanvas.width = collisionImg.width;
  colCanvas.height = collisionImg.height;
  colCtx.drawImage(collisionImg, 0, 0);
  collisionReady = true;
};

function pixelBlocked(x, y) {
  if (!collisionReady) return false;
  if (x < 0 || y < 0 || x >= colCanvas.width || y >= colCanvas.height) return true;
  const d = colCtx.getImageData(x, y, 1, 1).data;
  return (d[0] < 50 && d[1] < 50 && d[2] < 50);
}

function circleBlocked(cx, cy, r) {
  const N = 10;
  for (let i = 0; i < N; i++) {
    const a = (i / N) * Math.PI * 2;
    const px = cx + Math.cos(a) * r;
    const py = cy + Math.sin(a) * r;
    if (pixelBlocked(px, py)) return true;
  }
  return false;
}

// ======================================================
// PLAYER
// ======================================================
let player = {
  x: PLAYER_START.x,
  y: PLAYER_START.y,
  speed: 180,
  frame: 0,
  frameTimer: 0,
  scale: 0.20,
  facingLeft: false,
  moving: false,
  hitR: 40,
  hitOffsetY: 10
};

// ======================================================
// CAMERA (smooth follow)
// ======================================================
let camera = { x: 0, y: 0 };

function clampCamera() {
  if (bg.width > 0 && bg.height > 0) {
    camera.x = Math.max(0, Math.min(camera.x, bg.width - canvas.width));
    camera.y = Math.max(0, Math.min(camera.y, bg.height - canvas.height));
  }
}

function updateCamera() {
  const tx = player.x - canvas.width / 2;
  const ty = player.y - canvas.height / 2;
  camera.x += (tx - camera.x) * 0.1;
  camera.y += (ty - camera.y) * 0.1;
  clampCamera();
}

// ======================================================
// ANALOG JOYSTICK
// ======================================================
const joyDiv  = document.getElementById("joystick");
const stick   = document.getElementById("stick");

let joy = {
  active:false,
  dx:0, dy:0,
  originX:0, originY:0
};

canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  joy.active  = true;
  joy.originX = t.clientX;
  joy.originY = t.clientY;

  joyDiv.style.left = (t.clientX - 60) + "px";
  joyDiv.style.top  = (t.clientY - 60) + "px";
  joyDiv.style.display = "block";

  stick.style.left = "30px";
  stick.style.top  = "30px";
});

canvas.addEventListener("touchmove", e => {
  if (!joy.active) return;
  const t = e.touches[0];
  const dx = t.clientX - joy.originX;
  const dy = t.clientY - joy.originY;

  const dist = Math.hypot(dx, dy);
  const max = 40;

  let ndx = dx, ndy = dy;
  if (dist > max) {
    ndx = dx / dist * max;
    ndy = dy / dist * max;
  }

  stick.style.left = (30 + ndx) + "px";
  stick.style.top  = (30 + ndy) + "px";

  joy.dx = ndx / max;
  joy.dy = ndy / max;
});

canvas.addEventListener("touchend", () => {
  joy.active = false;
  joy.dx = joy.dy = 0;
  joyDiv.style.display = "none";
});

// ======================================================
// KEYBOARD (optional)
// ======================================================
const keys = { up:false, down:false, left:false, right:false };

function setKey(e, v) {
  switch(e.key){
    case "w": case "ArrowUp":    keys.up = v; break;
    case "s": case "ArrowDown":  keys.down = v; break;
    case "a": case "ArrowLeft":  keys.left = v; break;
    case "d": case "ArrowRight": keys.right = v; break;
  }
}
window.addEventListener("keydown", e => setKey(e,true));
window.addEventListener("keyup",   e => setKey(e,false));

// ======================================================
// UPDATE (WITH SLIDING COLLISION A)
// ======================================================
function update(dt){
  let vx = joy.dx;
  let vy = joy.dy;

  // Keyboard overrides (optional)
  if (keys.left)  vx = -1;
  if (keys.right) vx = 1;
  if (keys.up)    vy = -1;
  if (keys.down)  vy = 1;

  player.moving = (Math.abs(vx) > 0.05 || Math.abs(vy) > 0.05);

  if (player.moving) {
    const len = Math.hypot(vx, vy);
    if (len > 0) { vx /= len; vy /= len; }

    const nextX = player.x + vx * player.speed * dt;
    const nextY = player.y + vy * player.speed * dt;

    // ðŸ”¥ Slide movement logic (A)
    if (!circleBlocked(nextX, player.y + player.hitOffsetY, player.hitR))
      player.x = nextX;

    if (!circleBlocked(player.x, nextY + player.hitOffsetY, player.hitR))
      player.y = nextY;

    // Animation
    player.frameTimer += dt;
    if (player.frameTimer > 0.15) {
      player.frame = (player.frame + 1) % frames.length;
      player.frameTimer = 0;
    }

    if (vx < 0) player.facingLeft = true;
    else if (vx > 0) player.facingLeft = false;

  } else {
    player.frame = 0;
  }

  updateCamera();
}

// ======================================================
// DRAW
// ======================================================
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if (bg.complete && bg.width > 0) {
    ctx.drawImage(
      bg,
      camera.x, camera.y, canvas.width, canvas.height,
      0, 0, canvas.width, canvas.height
    );
  }

  const img = frames[player.frame];
  const w = img.width * player.scale;
  const h = img.height * player.scale;

  const drawX = player.x - camera.x - w/2;
  const drawY = player.y - camera.y - h/2;

  ctx.save();
  if (player.facingLeft) {
    ctx.translate(drawX + w/2, drawY + h/2);
    ctx.scale(-1,1);
    ctx.drawImage(img, -w/2, -h/2, w, h);
  } else {
    ctx.drawImage(img, drawX, drawY, w, h);
  }
  ctx.restore();
}

// ======================================================
// MAIN LOOP
// ======================================================
let last = 0;
function loop(t){
  const dt = (t - last) / 1000;
  last = t;

  update(dt);
  draw();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
