<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
      content="width=device-width,
               initial-scale=1.0,
               viewport-fit=cover,
               user-scalable=no" />
<title>Innerworld</title>

<style>
  html, body {
    margin: 0; padding: 0;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background: black;
    touch-action: none;
    font-family: sans-serif;
  }

  /* GAME CANVAS — area above bottom button region */
  #gameCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: calc(90vh - env(safe-area-inset-bottom));
    display: block;
  }

  /* Floating bottom UI buttons (no bar) */
  #uiButtons {
    position: fixed;
    bottom: calc(1.5vh + env(safe-area-inset-bottom));
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1.5vh;
    z-index: 9999;
    pointer-events: none; /* children handle clicks */
    font-size: 2.2vh;
    color: white;
  }

  #defaultUI {
    white-space: nowrap;
    pointer-events: auto;
  }

  /* Buttons */
  .ui-btn {
    background: rgba(255,200,150,0.95);
    padding: 1vh 2.4vh;
    border-radius: 1vh;
    font-size: 2.2vh;
    font-weight: bold;
    border: 2px solid white;
    color: black;
    display: none;
    white-space: nowrap;
    pointer-events: auto;
  }

  #fightButton {
    background: rgba(255,120,120,0.95);
  }

  #runButton {
    background: rgba(180,200,255,0.95);
  }

  #hitButton   { background: rgba(255,230,150,0.95); }
  #smackButton { background: rgba(255,210,150,0.95); }
  #punchButton { background: rgba(255,190,150,0.95); }
  #kickButton  { background: rgba(255,170,150,0.95); }

  /* Joystick */
  #joystick {
    position: absolute;
    width: 120px; height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.15);
    display: none;
    touch-action: none;
    z-index: 5000;
  }

  #stick {
    position: absolute;
    width: 60px; height: 60px;
    border-radius: 50%;
    background: rgba(255,255,255,0.4);
    left: 30px; top: 30px;
  }

  /* Fade overlay for RUN teleport / exit */
  #fadeOverlay {
    position: fixed;
    inset: 0;
    background: black;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
    z-index: 12000;
  }
</style>
</head>

<body>

<!-- GAME AREA -->
<canvas id="gameCanvas"></canvas>

<!-- FLOATING BOTTOM UI BUTTONS -->
<div id="uiButtons">
  <div id="defaultUI">Walk up to things…</div>

  <button id="harvestButton" class="ui-btn">HARVEST BLOSSOM</button>

  <!-- Monster choice -->
  <button id="fightButton" class="ui-btn">FIGHT</button>
  <button id="runButton"   class="ui-btn">RUN</button>

  <!-- Battle buttons -->
  <button id="hitButton"   class="ui-btn">HIT</button>
  <button id="smackButton" class="ui-btn">SMACK</button>
  <button id="punchButton" class="ui-btn">PUNCH</button>
  <button id="kickButton"  class="ui-btn">KICK</button>

  <!-- Exit back to overworld -->
  <button id="exitToMapButton" class="ui-btn">EXIT TO MAP</button>
</div>

<!-- JOYSTICK -->
<div id="joystick"><div id="stick"></div></div>

<!-- FADE OVERLAY -->
<div id="fadeOverlay"></div>

<script>
// =====================================================
// SHARED SAVE SYSTEM (matches outerworld index.html)
// =====================================================
const SAVE_KEY = "myGameSave";

function loadGame() {
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch (e) {
    console.warn("Failed to load save:", e);
    return null;
  }
}

function saveGame(game) {
  localStorage.setItem(SAVE_KEY, JSON.stringify(game));
}

// Load current game + tile
const game = loadGame();
let currentTile = null;
let tileBiome = "Plains";
let tileRarity = "common";

if (game && game.world && game.player && game.player.currentTile) {
  const { x, y } = game.player.currentTile;
  if (game.world[y] && game.world[y][x]) {
    currentTile = game.world[y][x];
    if (currentTile.biome) tileBiome = currentTile.biome;
    if (currentTile.rarity) tileRarity = currentTile.rarity;
  }
}

// Normalise biome/rarity into filenames
function getInnerworldAssetNames(biome, rarity) {
  let biomeKey = (biome || "Plains").toLowerCase();
  let rarityKey = (rarity || "common").toLowerCase();

  // Fallbacks for "Home" or "empty" etc.
  if (biomeKey === "home" || biomeKey === "empty") {
    biomeKey = "plains";
    if (rarityKey === "special") {
      // If you eventually add inner_home_special you can change this;
      // for now we use plains_common as a safe default
      rarityKey = "common";
    }
  }

  const bgName  = `inner_${biomeKey}_${rarityKey}.png`;
  const colName = `inner_${biomeKey}_${rarityKey}_collision.png`;

  return { bgName, colName };
}

const { bgName, colName } = getInnerworldAssetNames(tileBiome, tileRarity);
console.log("Loading innerworld assets:", bgName, colName);

// =====================================================
// CANVAS
// =====================================================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight * 0.90;
}
resize();
window.addEventListener("resize", resize);

let currentTime = 0; // for bobbing / breathing

// =====================================================
// ASSETS
// =====================================================
const bg = new Image();
bg.src = bgName; // biome+rarity-specific background

const collisionImg = new Image();
collisionImg.src = colName; // biome+rarity-specific collision map

const blossomImg = new Image();
blossomImg.src = "item_blossom.png";

const monsterIdleImg = new Image();
monsterIdleImg.src = "monster_starwolf_idle.png";

const monsterAttackImg = new Image();
monsterAttackImg.src = "monster_starwolf_attack.png";

const monsterHurtImg = new Image();
monsterHurtImg.src = "monster_starwolf_hurt.png";

const frames = ["player1.png","player2.png","player3.png"].map(src => {
  const i = new Image();
  i.src = src;
  return i;
});

// =====================================================
// COLLISION MAP
// =====================================================
const colCanvas = document.createElement("canvas");
const colCtx = colCanvas.getContext("2d");
let collisionReady = false;

collisionImg.onload = () => {
  colCanvas.width = collisionImg.width;
  colCanvas.height = collisionImg.height;
  colCtx.drawImage(collisionImg, 0, 0);
  collisionReady = true;
};

function pixelBlocked(x, y) {
  if (!collisionReady) return false;
  if (x < 0 || y < 0 || x >= colCanvas.width || y >= colCanvas.height) return true;
  const d = colCtx.getImageData(x, y, 1, 1).data;
  return d[0] < 50 && d[1] < 50 && d[2] < 50;
}

// Circle-based collision probe
function circleBlocked(cx, cy, r) {
  const N = 10;
  for (let i = 0; i < N; i++) {
    const angle = (i / N) * Math.PI * 2;
    const px = cx + Math.cos(angle) * r;
    const py = cy + Math.sin(angle) * r;
    if (pixelBlocked(px, py)) return true;
  }
  return false;
}

// =====================================================
// PLAYER
// =====================================================
let DEBUG_HITBOX = false;

const START_X = 500;
const START_Y = 500;

let player = {
  x: START_X,
  y: START_Y,
  speed: 180,
  frame: 0,
  frameTimer: 0,
  scale: 0.20,
  facingLeft: false,
  moving: false,

  hitR: 40,
  hitOffsetY: 10,

  hpMax: 20,
  hp: 20,
  hitFlash: 0,    // red flash timer when taking damage
  lungeOffsetX: 0,
  lungeOffsetY: 0
};

// =====================================================
// CAMERA
// =====================================================
let camera = { x: 0, y: 0 };

function clampCameraToBg() {
  const cw = canvas.width;
  const ch = canvas.height;
  if (bg.width > 0 && bg.height > 0) {
    camera.x = Math.max(0, Math.min(camera.x, bg.width - cw));
    camera.y = Math.max(0, Math.min(camera.y, bg.height - ch));
  } else {
    camera.x = 0;
    camera.y = 0;
  }
}

function updateCamera() {
  const cw = canvas.width;
  const ch = canvas.height;

  let tx = player.x - cw / 2;
  let ty = player.y - ch / 2;

  camera.x += (tx - camera.x) * 0.1;
  camera.y += (ty - camera.y) * 0.1;
  clampCameraToBg();
}

// =====================================================
// JOYSTICK
// =====================================================
const joyDiv = document.getElementById("joystick");
const stick = document.getElementById("stick");

let joy = { active:false, dx:0, dy:0, originX:0, originY:0 };

canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  joy.active = true;

  joy.originX = t.clientX;
  joy.originY = t.clientY;

  joyDiv.style.left = (t.clientX - 60) + "px";
  joyDiv.style.top  = (t.clientY - 60) + "px";
  joyDiv.style.display = "block";

  stick.style.left = "30px";
  stick.style.top  = "30px";
});

canvas.addEventListener("touchmove", e => {
  if (!joy.active) return;
  const t = e.touches[0];

  const dx = t.clientX - joy.originX;
  const dy = t.clientY - joy.originY;
  const dist = Math.hypot(dx, dy);
  const max = 40;

  let ndx = dx, ndy = dy;
  if (dist > max) {
    ndx = (dx / dist) * max;
    ndy = (dy / dist) * max;
  }

  stick.style.left = (30 + ndx) + "px";
  stick.style.top  = (30 + ndy) + "px";

  joy.dx = ndx / max;
  joy.dy = ndy / max;
});

canvas.addEventListener("touchend", () => {
  joy.active = false;
  joy.dx = joy.dy = 0;
  joyDiv.style.display = "none";
});

// =====================================================
// ITEMS (BLOSSOM — still hardcoded for now)
// =====================================================
let items = [
  { type: "blossom", x: 250, y: 250, harvested: false }
];

// =====================================================
// MONSTER (roaming + bobbing + breathing, no shadow)
// =====================================================
let monster = {
  x: 400,
  y: 200,
  alive: true,
  hpMax: 10,
  hp: 10,
  scale: 0.30,

  state: "idle",       // visual: "idle", "attack", "dying"
  aiState: "roam",     // logic: "roam", "pause", "aggro", "battle", "dying"
  fadeAlpha: 1,

  hitFlash: 0,         // red flash timer when taking damage
  lungeOffsetX: 0,
  lungeOffsetY: 0,
  facingLeft: false,

  // roaming parameters
  roamSpeed: 40,
  roamDirX: 1,
  roamDirY: 0,
  roamTimer: 0,
  pauseTimer: 0
};

function startMonsterRoam() {
  monster.aiState = "roam";
  const angle = Math.random() * Math.PI * 2;
  monster.roamDirX = Math.cos(angle);
  monster.roamDirY = Math.sin(angle);
  monster.roamTimer = 0.8 + Math.random() * 1.2; // 0.8–2.0s

  // Update facing based on overall direction
  if (monster.roamDirX < -0.1) monster.facingLeft = true;
  else if (monster.roamDirX > 0.1) monster.facingLeft = false;
}

function startMonsterPause() {
  monster.aiState = "pause";
  monster.pauseTimer = 0.7 + Math.random() * 0.8; // 0.7–1.5s
}

startMonsterRoam();

// =====================================================
// UI BUTTONS & MODES
// =====================================================
const defaultUI   = document.getElementById("defaultUI");
const harvestBtn  = document.getElementById("harvestButton");
const fightBtn    = document.getElementById("fightButton");
const runBtn      = document.getElementById("runButton");
const hitBtn      = document.getElementById("hitButton");
const smackBtn    = document.getElementById("smackButton");
const punchBtn    = document.getElementById("punchButton");
const kickBtn     = document.getElementById("kickButton");
const exitBtn     = document.getElementById("exitToMapButton");
const fadeOverlay = document.getElementById("fadeOverlay");

let currentUIMode = "default"; // "default", "blossom", "monsterChoice", "battle", "none"
let battleMode = false;
let battleBusy = false;        // turn-based lock
let runTeleportInProgress = false;

function setUIMode(mode) {
  currentUIMode = mode;

  defaultUI.style.display  = (mode === "default") ? "block" : "none";
  harvestBtn.style.display = (mode === "blossom") ? "inline-block" : "none";

  const monsterChoice = (mode === "monsterChoice");
  fightBtn.style.display   = monsterChoice ? "inline-block" : "none";
  runBtn.style.display     = monsterChoice ? "inline-block" : "none";

  const battle = (mode === "battle");
  hitBtn.style.display     = battle ? "inline-block" : "none";
  smackBtn.style.display   = battle ? "inline-block" : "none";
  punchBtn.style.display   = battle ? "inline-block" : "none";
  kickBtn.style.display    = battle ? "inline-block" : "none";

  if (mode === "none") {
    defaultUI.style.display  = "none";
    harvestBtn.style.display = "none";
    fightBtn.style.display   = "none";
    runBtn.style.display     = "none";
    hitBtn.style.display     = "none";
    smackBtn.style.display   = "none";
    punchBtn.style.display   = "none";
    kickBtn.style.display    = "none";
  }

  // EXIT button is always visible outside battle (you can tweak this)
  exitBtn.style.display = battle ? "none" : "inline-block";
}

setUIMode("default");

// movement lock: during battle, teleport, OR when FIGHT/RUN is up
function movementLocked() {
  return (
    battleMode ||
    runTeleportInProgress ||
    currentUIMode === "monsterChoice"
  );
}

// Blossom harvest
harvestBtn.addEventListener("click", () => {
  const item = items.find(i => i.type === "blossom" && !i.harvested);
  if (item) item.harvested = true;
  setUIMode("default");

  // here later you could add to inventory + saveGame(game)
});

// Exit back to overworld
exitBtn.addEventListener("click", () => {
  fadeOverlay.style.pointerEvents = "auto";
  fadeOverlay.style.opacity = "1";
  setTimeout(() => {
    window.location.href = "index.html";
  }, 400);
});

// =====================================================
// BATTLE & RUN ACTIONS
// =====================================================
function resetLunges() {
  player.lungeOffsetX = 0;
  player.lungeOffsetY = 0;
  monster.lungeOffsetX = 0;
  monster.lungeOffsetY = 0;
}

fightBtn.addEventListener("click", () => {
  if (!monster.alive) return;
  battleMode = true;
  battleBusy = false;
  monster.aiState = "battle";
  monster.state = "attack";
  setUIMode("battle");
});

runBtn.addEventListener("click", () => {
  if (!monster.alive) return;
  battleMode = false;
  battleBusy = false;
  monster.aiState = "roam";
  monster.state = "idle";
  setUIMode("none");
  resetLunges();
  startRunTeleport();
});

// Monster counter-attack (called after delay)
function performMonsterCounterAttack() {
  if (!monster.alive || !battleMode) {
    battleBusy = false;
    return;
  }

  // Monster enters attack pose + lunges toward player
  monster.state = "attack";
  const dx = player.x - monster.x;
  const dy = player.y - monster.y;
  const len = Math.hypot(dx, dy) || 1;
  const LUNGE_DIST = 20;

  if (dx < 0) monster.facingLeft = true;
  else monster.facingLeft = false;

  monster.lungeOffsetX = (dx / len) * LUNGE_DIST;
  monster.lungeOffsetY = (dy / len) * LUNGE_DIST;

  const MONSTER_DAMAGE = 2;
  player.hp -= MONSTER_DAMAGE;
  if (player.hp < 0) player.hp = 0;
  player.hitFlash = 0.18; // red flash on player

  // If player "dies", teleport them like a forced RUN and restore HP
  if (player.hp <= 0) {
    battleMode = false;
    battleBusy = false;
    monster.aiState = "roam";
    monster.state = "idle";
    setUIMode("none");
    resetLunges();
    startRunTeleport(() => {
      player.hp = player.hpMax;
      // could also saveGame(game) with new hp
    });
  } else {
    // Monster recovers from lunge
    setTimeout(() => {
      monster.lungeOffsetX = 0;
      monster.lungeOffsetY = 0;
      if (monster.alive && monster.aiState !== "dying") {
        monster.state = "idle";
      }
      // End of monster's turn: player can act again
      if (battleMode) {
        battleBusy = false;
        setUIMode("battle");
      }
    }, 200);
  }
}

// Player attack (turn-based)
function performAttack(damage) {
  if (!battleMode || !monster.alive || battleBusy) return;

  battleBusy = true;
  setUIMode("battle"); // keep only battle buttons visible

  // Player lunges 15px toward monster
  const dx = monster.x - player.x;
  const dy = monster.y - player.y;
  const len = Math.hypot(dx, dy) || 1;
  const LUNGE_DIST = 15;

  player.lungeOffsetX = (dx / len) * LUNGE_DIST;
  player.lungeOffsetY = (dy / len) * LUNGE_DIST;

  // Apply damage to monster
  monster.hp -= damage;
  if (monster.hp < 0) monster.hp = 0;
  monster.hitFlash = 0.18; // red flash on monster

  // Check for monster death
  if (monster.hp <= 0) {
    monster.hp = 0;
    if (monster.alive) {
      monster.alive = false;
      monster.state = "dying";
      monster.aiState = "dying";
      monster.fadeAlpha = 1;
    }
    // End battle after brief moment so flash shows
    setTimeout(() => {
      battleMode = false;
      battleBusy = false;
      setUIMode("default");
      resetLunges();
    }, 250);
    return;
  }

  // After short time, remove player lunge + monster flash
  setTimeout(() => {
    player.lungeOffsetX = 0;
    player.lungeOffsetY = 0;
    monster.hitFlash = 0;

    if (!battleMode || !monster.alive) {
      battleBusy = false;
      return;
    }

    // Delay before monster counter-attacks (slightly longer for readability)
    setTimeout(() => {
      performMonsterCounterAttack();
    }, 500);
  }, 180);
}

// Attach attacks to buttons
hitBtn.addEventListener("click",   () => performAttack(2));
smackBtn.addEventListener("click", () => performAttack(3));
punchBtn.addEventListener("click", () => performAttack(4));
kickBtn.addEventListener("click",  () => performAttack(5));

// =====================================================
// RUN TELEPORT WITH FADE
// =====================================================
function startRunTeleport(onAfterTeleport) {
  runTeleportInProgress = true;
  fadeOverlay.style.pointerEvents = "auto";
  fadeOverlay.style.opacity = "1";

  // Fade to black, then teleport
  setTimeout(() => {
    // Teleport player to start (innerworld-local)
    player.x = START_X;
    player.y = START_Y;
    camera.x = player.x - canvas.width / 2;
    camera.y = player.y - canvas.height / 2;
    clampCameraToBg();

    if (typeof onAfterTeleport === "function") {
      onAfterTeleport();
    }

    // Fade back in
    fadeOverlay.style.opacity = "0";

    setTimeout(() => {
      fadeOverlay.style.pointerEvents = "none";
      runTeleportInProgress = false;
      setUIMode("default");
    }, 400);
  }, 400);
}

// =====================================================
// MONSTER ROAMING AI
// =====================================================
function updateMonsterAI(dt) {
  if (!monster.alive || monster.aiState === "dying") return;
  if (battleMode) {
    monster.aiState = "battle";
    return;
  }

  // While in aggro (player close, FIGHT/RUN up), monster stands still
  if (monster.aiState === "aggro") {
    return;
  }

  if (monster.aiState === "pause") {
    monster.pauseTimer -= dt;
    if (monster.pauseTimer <= 0) {
      startMonsterRoam();
    }
  } else if (monster.aiState === "roam") {
    const speed = monster.roamSpeed;
    const nextX = monster.x + monster.roamDirX * speed * dt;
    const nextY = monster.y + monster.roamDirY * speed * dt;

    // Use a small circle for monster collision
    const probeOffsetY = 10;
    const probeRadius = 30;

    if (!circleBlocked(nextX, nextY + probeOffsetY, probeRadius)) {
      monster.x = nextX;
      monster.y = nextY;
    } else {
      // Hit an obstacle → pause, then new direction
      startMonsterPause();
      return;
    }

    monster.roamTimer -= dt;
    if (monster.roamTimer <= 0) {
      startMonsterPause();
    }
  }
}

// =====================================================
// LOOP
// =====================================================
let last = 0;
function loop(t) {
  const dt = (t - last) / 1000;
  last = t;
  currentTime = t;

  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// =====================================================
// UPDATE
// =====================================================
function update(dt) {
  const lockMove = movementLocked();

  // Player movement
  if (!lockMove) {
    player.moving = Math.abs(joy.dx) > 0.05 || Math.abs(joy.dy) > 0.05;

    if (player.moving) {
      const nextX = player.x + joy.dx * player.speed * dt;
      const nextY = player.y + joy.dy * player.speed * dt;

      if (!circleBlocked(nextX, player.y + player.hitOffsetY, player.hitR))
        player.x = nextX;

      if (!circleBlocked(player.x, nextY + player.hitOffsetY, player.hitR))
        player.y = nextY;
    }
  } else {
    player.moving = false;
  }

  // Player animation
  if (player.moving) {
    player.frameTimer += dt;
    if (player.frameTimer > 0.15) {
      player.frame = (player.frame + 1) % 3;
      player.frameTimer = 0;
    }
  } else {
    player.frame = 0;
  }

  // Facing
  if (!lockMove) {
    if (joy.dx < -0.05) player.facingLeft = true;
    else if (joy.dx > 0.05) player.facingLeft = false;
  }

  // Damage flash timers
  if (player.hitFlash > 0) {
    player.hitFlash -= dt;
    if (player.hitFlash < 0) player.hitFlash = 0;
  }

  if (monster.hitFlash > 0) {
    monster.hitFlash -= dt;
    if (monster.hitFlash < 0) monster.hitFlash = 0;
  }

  // Monster fade-out when dying
  if (!monster.alive && monster.aiState === "dying") {
    monster.fadeAlpha -= dt * 1.8; // fade over ~0.55s
    if (monster.fadeAlpha < 0) monster.fadeAlpha = 0;
  }

  // Lunge offset soft decay
  player.lungeOffsetX *= 0.85;
  player.lungeOffsetY *= 0.85;
  if (Math.abs(player.lungeOffsetX) < 0.01) player.lungeOffsetX = 0;
  if (Math.abs(player.lungeOffsetY) < 0.01) player.lungeOffsetY = 0;

  monster.lungeOffsetX *= 0.85;
  monster.lungeOffsetY *= 0.85;
  if (Math.abs(monster.lungeOffsetX) < 0.01) monster.lungeOffsetX = 0;
  if (Math.abs(monster.lungeOffsetY) < 0.01) monster.lungeOffsetY = 0;

  // Monster roaming AI
  updateMonsterAI(dt);

  // Proximity UI logic only when not in battle or teleport
  if (!movementLocked()) {
    let nearMonster = false;
    if (monster.alive) {
      const dx = player.x - monster.x;
      const dy = player.y - monster.y;
      const dist = Math.hypot(dx, dy);
      if (dist < 90) nearMonster = true;
    }

    let nearBlossom = false;
    if (!nearMonster) { // monster has priority
      for (const item of items) {
        if (item.harvested) continue;
        const dx = player.x - item.x;
        const dy = player.y - item.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 80) {
          nearBlossom = true;
          break;
        }
      }
    }

    if (nearMonster) {
      setUIMode("monsterChoice");
      if (monster.alive && !battleMode) {
        monster.aiState = "aggro";
        monster.state = "attack";
        // face the player when in aggro
        const dx = player.x - monster.x;
        if (dx < 0) monster.facingLeft = true;
        else if (dx > 0) monster.facingLeft = false;
      }
    } else if (nearBlossom) {
      setUIMode("blossom");
      if (monster.alive && monster.aiState === "aggro" && !battleMode) {
        monster.aiState = "roam";
        monster.state = "idle";
        startMonsterRoam();
      }
    } else if (currentUIMode !== "default") {
      setUIMode("default");
      if (monster.alive && monster.aiState === "aggro" && !battleMode) {
        monster.aiState = "roam";
        monster.state = "idle";
        startMonsterRoam();
      }
    }
  }

  updateCamera();
}

// =====================================================
// DRAW HELPERS
// =====================================================
function drawHPBubbleOval(worldX, worldY, hp, hpMax) {
  const screenX = worldX - camera.x;
  const screenY = worldY - camera.y;

  const text = `♥ ${hp}/${hpMax}`;
  ctx.save();
  ctx.font = "12px sans-serif";
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";

  const paddingX = 6;
  const paddingY = 4;
  const textWidth = ctx.measureText(text).width;
  const w = textWidth + paddingX * 2;
  const h = 18;

  const cx = screenX;
  const cy = screenY;

  const rx = w / 2;
  const ry = h / 2;

  // Drop shadow ellipse for bubble
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.ellipse(cx, cy + 2, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();

  // White oval
  ctx.fillStyle = "white";
  ctx.beginPath();
  ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();

  // Text inside
  ctx.fillStyle = "black";
  ctx.fillText(text, cx, cy);

  ctx.restore();
}

function drawHitFlashRect(x, y, w, h, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = "red";
  ctx.fillRect(x, y, w, h);
  ctx.restore();
}

// =====================================================
// DRAW
// =====================================================
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Background (biome+rarity-specific)
  ctx.drawImage(
    bg,
    camera.x, camera.y,
    canvas.width, canvas.height,
    0, 0,
    canvas.width, canvas.height
  );

  // Items (blossom)
  for (const item of items) {
    if (item.harvested) continue;

    if (item.type === "blossom") {
      const size = 80;
      ctx.drawImage(
        blossomImg,
        item.x - camera.x - size/2,
        item.y - camera.y - size/2,
        size,
        size
      );
    }
  }

  // Monster
  if (monster.alive || (monster.aiState === "dying" && monster.fadeAlpha > 0)) {
    // Decide which sprite to use
    let mImg = monsterIdleImg;

    if (monster.aiState === "dying") {
      mImg = monsterHurtImg;
    } else if (monster.hitFlash > 0) {
      mImg = monsterHurtImg;
    } else if (
      monster.state === "attack" ||
      (monster.alive && currentUIMode === "monsterChoice" && !battleMode)
    ) {
      // Attack sprite while lunging OR when FIGHT/RUN UI is up
      mImg = monsterAttackImg;
    }

    const baseScale = monster.scale;
    const mw = mImg.width * baseScale;
    const mh = mImg.height * baseScale;
    const worldMX = monster.x + monster.lungeOffsetX;
    const worldMY = monster.y + monster.lungeOffsetY;

    const screenMX = worldMX - camera.x;
    const screenMY = worldMY - camera.y;

    // Bobbing & breathing
    const bob = Math.sin(currentTime / 500) * 4;            // up/down
    const breathe = 1 + Math.sin(currentTime / 700) * 0.02; // ±2% scale

    // Monster sprite with bobbing + breathing + facing
    ctx.save();
    ctx.globalAlpha = (monster.aiState === "dying") ? monster.fadeAlpha : 1;
    ctx.translate(screenMX, screenMY + bob);
    const scaleX = (monster.facingLeft ? -1 : 1) * breathe;
    ctx.scale(scaleX, breathe);
    ctx.drawImage(mImg, -mw/2, -mh/2, mw, mh);
    ctx.restore();

    // Red hit flash on monster (sprite-sized)
    if (monster.hitFlash > 0) {
      const alpha = (monster.hitFlash / 0.18) * 0.18; // subtle
      const fxW = mw * breathe;
      const fxH = mh * breathe;
      const fxX = screenMX - fxW / 2;
      const fxY = (screenMY + bob) - fxH / 2;
      drawHitFlashRect(fxX, fxY, fxW, fxH, alpha);
    }

    // Monster HP bubble only during battle and while alive
    if (battleMode && monster.alive) {
      drawHPBubbleOval(monster.x, monster.y - 60, monster.hp, monster.hpMax);
    }
  }

  // Player
  const img = frames[player.frame];
  const w = img.width * player.scale;
  const h = img.height * player.scale;

  const worldPX = player.x + player.lungeOffsetX;
  const worldPY = player.y + player.lungeOffsetY;
  const drawX = worldPX - camera.x - w/2;
  const drawY = worldPY - camera.y - h/2;

  if (player.facingLeft) {
    ctx.save();
    ctx.translate(drawX + w/2, drawY + h/2);
    ctx.scale(-1, 1);
    ctx.drawImage(img, -w/2, -h/2, w, h);
    ctx.restore();
  } else {
    ctx.drawImage(img, drawX, drawY, w, h);
  }

  // Red hit flash on player (sprite-sized)
  if (player.hitFlash > 0) {
    const alpha = (player.hitFlash / 0.18) * 0.18; // subtle
    drawHitFlashRect(drawX, drawY, w, h, alpha);
  }

  // Player HP bubble only during battle
  if (battleMode) {
    drawHPBubbleOval(player.x, player.y - 60, player.hp, player.hpMax);
  }

  // Debug Hitbox
  if (DEBUG_HITBOX) {
    const c2x = player.x - camera.x;
    const c2y = player.y - camera.y + player.hitOffsetY;

    ctx.strokeStyle = "red";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(c2x, c2y, player.hitR, 0, Math.PI * 2);
    ctx.stroke();

    ctx.fillStyle = "cyan";
    for (let i = 0; i < 10; i++) {
      const a = (i / 10) * Math.PI * 2;
      const px = c2x + Math.cos(a) * player.hitR;
      const py = c2y + Math.sin(a) * player.hitR;
      ctx.fillRect(px - 2, py - 2, 4, 4);
    }
  }
}
</script>

</body>
</html>
