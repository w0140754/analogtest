<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,viewport-fit=cover,user-scalable=no" />
<title>Outerworld — Persistent 5x5 Grid</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #05070b;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: #f9fafb;
    overflow: hidden;
  }

  body {
    display: flex;
    flex-direction: column;
  }

  /* ===== LAYOUT ===== */
  #outerRoot {
    display: flex;
    flex-direction: column;
    height: 100vh;
  }

  /* Top banner */
  #banner {
    flex: 0 0 auto;
    padding: 8px 12px;
    background: linear-gradient(to right, #111827, #020617);
    border-bottom: 1px solid rgba(148,163,184,0.3);
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  #banner-left {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  #banner-title {
    font-weight: 600;
    font-size: 13px;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    color: #cbd5f5;
  }

  #banner-sub {
    font-size: 12px;
    color: #9ca3af;
  }

  #banner-coords {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 999px;
    background: rgba(15,23,42,0.9);
    border: 1px solid rgba(148,163,184,0.5);
    color: #e5e7eb;
    white-space: nowrap;
  }

  /* Middle: grid wrapper */
  #gridWrapper {
    flex: 1 1 auto;
    padding: 8px 12px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  /* Square grid area */
  #gridSquare {
    position: relative;
    width: min(90vw, 90vh);
    max-width: 560px;
    aspect-ratio: 1 / 1;
    background: radial-gradient(circle at top, #1e293b, #020617);
    border-radius: 16px;
    box-shadow: 0 18px 40px rgba(15,23,42,0.9);
    padding: 10px;
    box-sizing: border-box;
    display: flex;
  }

  #grid {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(5, 1fr);
    gap: 4px;
  }

  .tile {
    position: relative;
    border-radius: 8px;
    overflow: hidden;
    background-color: #020617;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    cursor: pointer;
    box-shadow: inset 0 0 0 1px rgba(15,23,42,0.9);
    transition: transform 0.1s ease, box-shadow 0.1s ease;
  }

  .tile:active { transform: scale(0.97); }

  .tile-empty {
    background-color: #020617;
    box-shadow: inset 0 0 0 1px rgba(31,41,55,0.8);
  }

  .tile-highlight-playable {
    box-shadow:
      0 0 0 2px rgba(250,204,21,0.9),
      0 0 18px rgba(250,204,21,0.7);
  }

  .tile-player::after {
    content: "⬤";
    position: absolute;
    bottom: 4px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 18px;
    text-shadow: 0 0 4px rgba(0,0,0,0.8);
  }

  .tile-player {
    box-shadow:
      0 0 0 2px rgba(96,165,250,0.8),
      0 0 22px rgba(37,99,235,0.95);
  }

  /* ===== BOTTOM UI ===== */
  #bottomUI {
    flex: 0 0 auto;
    background: linear-gradient(to top, #020617, #020617f0);
    border-top: 1px solid rgba(148,163,184,0.4);
    padding: 6px 10px 8px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  #enterRow {
    display: flex;
    justify-content: center;
    margin-bottom: 2px;
  }

  #enterButton {
    display: none;
    padding: 6px 18px;
    font-size: 14px;
    border-radius: 999px;
    border: 1px solid rgba(249,250,251,0.9);
    background: linear-gradient(to right, #22c55e, #4ade80);
    color: #022c22;
    font-weight: 600;
    letter-spacing: 0.03em;
    text-transform: uppercase;
    cursor: pointer;
  }

  /* Cards */
  #cardRow { display: flex; gap: 10px; overflow-x: auto; }
  .card { width: 60px; height: 84px; border-radius: 8px; cursor: pointer; background: #0f172a; }
  .card img { width: 100%; height: 100%; object-fit: cover; }
  .card-count { position: absolute; bottom: 4px; right: 4px; background: #0008; padding: 2px 4px; border-radius: 6px; font-size: 10px; }

  .card-disabled { opacity: 0.35; }
  .card-selected { transform: scale(1.1); border: 2px solid #facc15; }

</style>
</head>
<body>
<div id="outerRoot">

  <!-- ===== TOP BANNER ===== -->
  <div id="banner">
    <div id="banner-left">
      <div id="banner-title">Outerworld</div>
      <div id="banner-sub">Tile: <span id="banner-tileName">Home</span></div>
    </div>
    <div id="banner-coords">
      Pos: <span id="banner-coordText">3, 3</span>
    </div>
  </div>

  <!-- ===== GRID ===== -->
  <div id="gridWrapper">
    <div id="gridSquare">
      <div id="grid"></div>
    </div>
  </div>

  <!-- ===== BOTTOM UI ===== -->
  <div id="bottomUI">
    <div id="enterRow"><button id="enterButton">ENTER</button></div>
    <div id="cardRow"><div id="cardRowTitle">Cards</div></div>
  </div>

</div>

<script>
// =====================================================
// SAVE SYSTEM
// =====================================================
const SAVE_KEY = "myGameSaveV1";

// Attempt to load game state
function loadGame() {
  const raw = localStorage.getItem(SAVE_KEY);
  if (!raw) return false;

  const data = JSON.parse(raw);

  world = data.world || world;
  playerX = data.player?.x ?? playerX;
  playerY = data.player?.y ?? playerY;
  cards   = data.cards   || cards;

  return true;
}

// Save game state
function saveGame() {
  const data = {
    world,
    player: { x: playerX, y: playerY },
    cards
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(data));
}

// =====================================================
// GRID + CARDS + UI LOGIC (same as before)
// =====================================================

// --- world data ---
const SIZE = 5;
let world = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));

let playerX = 2;
let playerY = 2;

// Load saved data if present
const loaded = loadGame();

// Default tile if no save existed
if (!loaded) {
  world[playerY][playerX] = { type: "home" };
  saveGame();
}

// Tile type definitions
const TILE_TYPES = {
  home:   { label: "Home",   image: "tile_home.png" },
  plains: { label: "Plains", image: "tile_plains.png" },
  hills:  { label: "Hills",  image: "tile_hills.png" },
  forest: { label: "Forest", image: "tile_forest.png" }
};

// Cards
let cards = cards || [
  { type: "plains", label: "Plains", image: "card_plains.png", count: 3 },
  { type: "hills",  label: "Hills",  image: "card_hills.png",  count: 2 },
  { type: "forest", label: "Forest", image: "card_forest.png", count: 2 }
];

let selectedCardType = null;

// =====================================================
// DOM REFS
// =====================================================
const gridEl            = document.getElementById("grid");
const bannerTileNameEl  = document.getElementById("banner-tileName");
const bannerCoordTextEl = document.getElementById("banner-coordText");
const enterButtonEl     = document.getElementById("enterButton");
const cardRowEl         = document.getElementById("cardRow");

// =====================================================
// HELPERS
// =====================================================
function inBounds(x,y){ return x>=0 && x<SIZE && y>=0 && y<SIZE; }
function isAdjacent(x,y){ return Math.abs(x-playerX)+Math.abs(y-playerY)===1; }
function getTile(x,y){ return world[y][x]; }
function setTile(x,y,type){ world[y][x]={type}; }

function getCard(type){ return cards.find(c=>c.type===type); }

function playableTiles(type){
  const c=getCard(type);
  if (!c || c.count<=0) return [];
  const out=[];
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const[dX,dY]of dirs){
    const nx=playerX+dX, ny=playerY+dY;
    if(inBounds(nx,ny) && world[ny][nx]===null) out.push({x:nx,y:ny});
  }
  return out;
}

// =====================================================
// GRID DOM
// =====================================================
let tileElements = [];

function initGridDOM(){
  gridEl.innerHTML="";
  tileElements=[];
  for(let y=0;y<SIZE;y++){
    const row=[];
    for(let x=0;x<SIZE;x++){
      const d=document.createElement("div");
      d.className="tile";
      d.dataset.x=x;
      d.dataset.y=y;
      d.addEventListener("click",onTileClick);
      gridEl.appendChild(d);
      row.push(d);
    }
    tileElements.push(row);
  }
}

function renderGrid(){
  const playable = selectedCardType
    ? playableTiles(selectedCardType).map(c=>`${c.x},${c.y}`)
    : [];

  for(let y=0;y<SIZE;y++){
    for(let x=0;x<SIZE;x++){
      const div = tileElements[y][x];
      const tile = world[y][x];

      div.className="tile";
      div.style.backgroundImage="";

      if(!tile){
        div.classList.add("tile-empty");
      } else {
        const def=TILE_TYPES[tile.type];
        if(def) div.style.backgroundImage=`url('${def.image}')`;
      }

      if(x===playerX && y===playerY)
        div.classList.add("tile-player");

      if(playable.includes(`${x},${y}`))
        div.classList.add("tile-highlight-playable");
    }
  }
}

// =====================================================
// BANNER + ENTER BUTTON
// =====================================================
function updateBanner(){
  const tile=getTile(playerX,playerY);
  bannerTileNameEl.textContent = TILE_TYPES[tile.type]?.label || tile.type;
  bannerCoordTextEl.textContent = `${playerX+1}, ${playerY+1}`;
}

function updateEnterButton(){
  const tile=getTile(playerX,playerY);
  if(!tile){ enterButtonEl.style.display="none"; return; }
  const label=TILE_TYPES[tile.type]?.label || tile.type;
  enterButtonEl.textContent=`ENTER ${label.toUpperCase()}`;
  enterButtonEl.style.display="inline-block";
}

// When entering → save and switch pages
enterButtonEl.addEventListener("click",()=>{
  saveGame();
  window.location.href="innerworld.html";
});

// =====================================================
// CARDS ROW
// =====================================================
let cardElements=[];

function initCardsDOM(){
  const extra = [...cardRowEl.children].slice(1);
  extra.forEach(el=>cardRowEl.removeChild(el));
  cardElements=[];

  for(const c of cards){
    const d=document.createElement("div");
    d.className="card";
    d.dataset.type=c.type;

    const img=document.createElement("img");
    img.src=c.image;
    d.appendChild(img);

    const cnt=document.createElement("div");
    cnt.className="card-count";
    d.appendChild(cnt);

    d.addEventListener("click",onCardClick);

    cardRowEl.appendChild(d);
    cardElements.push({ type:c.type, el:d, countEl:cnt });
  }
}

function renderCards(){
  for(const entry of cardElements){
    const c=getCard(entry.type);
    entry.countEl.textContent=`x${c.count}`;
    entry.el.classList.toggle("card-disabled", c.count<=0);
    entry.el.classList.toggle("card-selected", selectedCardType===entry.type);
  }
}

function onCardClick(e){
  const type=e.currentTarget.dataset.type;
  const c=getCard(type);
  if(c.count<=0) return;

  selectedCardType = selectedCardType===type ? null : type;
  renderCards();
  renderGrid();
  saveGame();
}

// =====================================================
// TILE CLICK
// =====================================================
function onTileClick(e){
  const x=parseInt(e.currentTarget.dataset.x);
  const y=parseInt(e.currentTarget.dataset.y);
  const tile=getTile(x,y);

  // Use card
  if(selectedCardType){
    const playable=playableTiles(selectedCardType).map(c=>`${c.x},${c.y}`);
    if(playable.includes(`${x},${y}`)){
      const card=getCard(selectedCardType);
      setTile(x,y,selectedCardType);
      card.count--;
      if(card.count<=0) selectedCardType=null;

      renderCards();
      renderGrid();
      updateBanner();
      updateEnterButton();
      saveGame();
    }
    return;
  }

  // Move
  if(isAdjacent(x,y) && tile){
    playerX=x;
    playerY=y;
    renderGrid();
    updateBanner();
    updateEnterButton();
    saveGame();
  }
}

// =====================================================
// INIT
// =====================================================
function init(){
  initGridDOM();
  initCardsDOM();
  renderGrid();
  renderCards();
  updateBanner();
  updateEnterButton();
}

init();
</script>

</body>
</html>
